#!/bin/bash

# -----------------------------------------------------------------------------
# ExcludonFinder - Wrapper Script
# -----------------------------------------------------------------------------
# This script provides a user-friendly interface for running the main pipeline.
# It handles argument parsing, requirement checks, and formats the output.
# -----------------------------------------------------------------------------

# Get the absolute directory where this script is located for robust pathing.
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Function to print the ASCII art header.
print_header(){
  cat << 'EOF'
    ______            _           _              ______ _            _
  |  ____|          | |         | |             |  ____(_)          | |
  | |__  __  _____| |_    _  __| | ___  _ __    | |__   _ _ __    __| | ___ _ __
  |  __| \ \/ / __| | | | |/ _` |/ _ \| '_ \   |  __| | | '_ \ / _` |/ _ \ '__|
  | |____ >  < (__| | |_| | (_| | (_) | | | |  | |    | | | | | (_| |  __/ |
  |______/_/\_\___|_|\__,_|\__,_|\___/|_| |_|  |_|    |_|_| |_|\__,_|\___|_|
      --------------------------------------------
              --------------------------------------------
                          --------------------------------------------
                                      --------------------------------------------
                                    V1.1.0
EOF
}

# Function to print formatted section headers.
print_section() {
    local title="$1"
    local width=78
    local title_len=${#title}
    local padding=$(( (width - title_len) / 2 - 2 ))

    echo "//==============================================================================\\\\"
    echo "||                                                                              ||"
    printf "||%*s%s%*s||\n" $padding "" "$title" $(( width - title_len - padding  )) ""
    echo "||                                                                              ||"
}

# Function to print a formatted status line, truncating if necessary.
print_status() {
    local message="$1"
    printf "||  %-76.76s||\n" "$message"
}

# Function to print the section footer.
print_footer() {
    echo "||                                                                              ||"
    echo "\\\==============================================================================//"
    echo
}

# ✅ RESCUED LOGIC: Function to detect if a FASTQ file is interleaved.
detect_interleaved() {
    local fastq="$1"
    # Read the first 8 lines (2 complete reads) to check headers.
    local first_header=$(head -n 1 "$fastq" 2>/dev/null)
    local fifth_header=$(head -n 5 "$fastq" 2>/dev/null | tail -n 1)

    if [[ -n "$first_header" && -n "$fifth_header" ]]; then
        local id1=$(echo "$first_header" | cut -d' ' -f1)
        local id2=$(echo "$fifth_header" | cut -d' ' -f1)
        # If IDs match, it's likely interleaved.
        if [[ "$id1" == "$id2" ]]; then
            return 0  # Success (is interleaved)
        fi
    fi
    return 1 # Failure (is not interleaved)
}

# Function to parse command-line arguments.
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f) shift; fasta_file="$1" ;;
            -g) shift; gff_file="$1" ;;
            -1) shift; fastq_r1="$1" ;;
            -2) shift; fastq_r2="$1" ;;
            -t) shift; threshold="$1" ;;
            -j) shift; threads="$1" ;;
            -o) shift; output_dir_arg="$1" ;;
            -l) long_reads="yes" ;;
            -k) keep_intermediate="yes" ;;
            -C) qc="yes" ;;
            *) ;; # Allow other options to pass through to main.sh
        esac
        shift
    done
}

# Function to check if a file exists.
check_file() {
    local file="$1"
    local desc="$2"
    if [[ ! -f "$file" ]]; then
        print_status "Error: $desc file not found: $file"
        return 1
    fi
    return 0
}

# Function to check all requirements before running.
check_requirements() {
    local errors=0
    
    # Use the absolute path to ensure main.sh is found.
    if [[ ! -d "$SCRIPT_DIR" ]] || [[ ! -f "$SCRIPT_DIR/main.sh" ]]; then
        print_status "Error: scripts directory or main.sh not found in $SCRIPT_DIR"
        return 1
    fi

    # Check for mandatory input files.
    check_file "$fasta_file" "FASTA" || ((errors++))
    check_file "$gff_file" "GFF" || ((errors++))
    check_file "$fastq_r1" "FASTQ R1" || ((errors++))

    if [[ -n "$fastq_r2" ]]; then
        check_file "$fastq_r2" "FASTQ R2" || ((errors++))
    fi

    return $errors
}

# Main execution block.
main() {
    clear
    print_header
    parse_args "$@"

    if ! check_requirements; then
        print_section "Error"
        print_status "Fatal: Missing required files or directories."
        print_footer
        exit 1
    fi

    # ✅ RESCUED LOGIC: Determine the data type for display.
    local data_type
    if [[ -n "$fastq_r2" ]]; then
        data_type="Paired-end"
    elif detect_interleaved "$fastq_r1"; then
        data_type="Paired-end (interleaved)"
    else
        data_type="Single-end"
    fi

    # Print the configuration summary.
    print_section "Configuration"
    print_status "FASTA file  : $fasta_file"
    print_status "GFF file    : $gff_file"
    print_status "FASTQ R1    : $fastq_r1"
    [[ -n "$fastq_r2" ]] && print_status "FASTQ R2    : $fastq_r2"
    [[ -n "$output_dir_arg" ]] && print_status "Output dir  : $output_dir_arg"
    print_status "Threads     : ${threads:-8}"
    print_status "Threshold   : ${threshold:-0.5}"
    print_status "Data type   : $data_type"
    [[ "$long_reads" == "yes" ]] && print_status "Long reads  : Yes"
    [[ "$keep_intermediate" == "yes" ]] && print_status "Keep files  : Yes"
    [[ "$qc" == "yes" ]] && print_status "QC enabled  : Yes"
    print_footer

    print_section "Running pipeline"

    # Execute the main script using its absolute path and process its output.
    bash "${SCRIPT_DIR}/main.sh" "$@" 2>&1 | while IFS= read -r line; do
        case "$line" in
            *"The analysis is finished"*)
                print_footer
                print_section "Analysis Complete"
                print_status "All processes finished successfully."
                print_footer
                ;;
            *"ERROR:"*)
                print_section "Error"
                print_status "${line#ERROR: }"
                print_footer
                ;;
            *)
                # Print other important, non-empty lines from main.sh
                if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*$ && ! "$line" =~ ^"###" ]]; then
                    print_status "$line"
                fi
                ;;
        esac
    done

    # Check the exit status of the main script.
    if [ ${PIPESTATUS[0]} -ne 0 ]; then
        print_section "Execution Failed"
        print_status "The pipeline failed with an error. Please check the logs."
        print_footer
        exit 1
    fi
}

# Run the main function with all provided arguments.
main "$@"
